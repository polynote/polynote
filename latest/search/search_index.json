{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"about/","text":"Maintainers \u00b6 Polynote is maintained by: jeremyrsmith jonathanindig Acknowledgements \u00b6 Thank you to all the contributors from the Polynote community: Polynote is made possible by the investment of Netflix OSS .","title":"About"},{"location":"about/#maintainers","text":"Polynote is maintained by: jeremyrsmith jonathanindig","title":"Maintainers"},{"location":"about/#acknowledgements","text":"Thank you to all the contributors from the Polynote community: Polynote is made possible by the investment of Netflix OSS .","title":"Acknowledgements"},{"location":"contribute/","text":"Polynote welcomes contributions of all kinds from the open source community. Contributing code \u00b6 Pull requests are accepted on our GitHub repository . Website corrections are also accepted for this website at its repository . If you'd like to contribute a pull request, but you're not sure what to work on, look for issues labelled \"good first issue.\" Please read the Contribution guidelines before submitting a pull request. Issues and Documentation \u00b6 You can contribute to the Polynote project without writing a single line of code! We also need help with writing and maintaining documentation, and with user testing. Documentation pull requests can be submitted to the main repository (you'll find the documentation in markdown format in the docs directory ). We'd also appreciate issue reports that you find while using the software. Community \u00b6 Polynote has a gitter chat: Please maintain appropriate, professional conduct while participating in our community. This includes all channels of communication. To report unwelcoming behavior or harassment taking place in the Polynote community, please contact a project maintainer via private chat.","title":"Contribute"},{"location":"contribute/#contributing-code","text":"Pull requests are accepted on our GitHub repository . Website corrections are also accepted for this website at its repository . If you'd like to contribute a pull request, but you're not sure what to work on, look for issues labelled \"good first issue.\" Please read the Contribution guidelines before submitting a pull request.","title":"Contributing code"},{"location":"contribute/#issues-and-documentation","text":"You can contribute to the Polynote project without writing a single line of code! We also need help with writing and maintaining documentation, and with user testing. Documentation pull requests can be submitted to the main repository (you'll find the documentation in markdown format in the docs directory ). We'd also appreciate issue reports that you find while using the software.","title":"Issues and Documentation"},{"location":"contribute/#community","text":"Polynote has a gitter chat: Please maintain appropriate, professional conduct while participating in our community. This includes all channels of communication. To report unwelcoming behavior or harassment taking place in the Polynote community, please contact a project maintainer via private chat.","title":"Community"},{"location":"docs/","text":"Getting Started \u00b6 Welcome to Polynote! Polynote is a different kind of notebook. It supports mixing multiple languages in one notebook, and sharing data between them seamlessly. It encourages reproducible notebooks with its immutable data model. Get started by installing Polynote , or by taking a tour of the UI! When you're ready, check out the User Guide for more information. Or if you need to customize your installation, head over to the configuration section.","title":"Docs"},{"location":"docs/#getting-started","text":"Welcome to Polynote! Polynote is a different kind of notebook. It supports mixing multiple languages in one notebook, and sharing data between them seamlessly. It encourages reproducible notebooks with its immutable data model. Get started by installing Polynote , or by taking a tour of the UI! When you're ready, check out the User Guide for more information. Or if you need to customize your installation, head over to the configuration section.","title":"Getting Started"},{"location":"docs/about-menu/","text":"","title":"About Menu"},{"location":"docs/advanced/","text":"This page has some details about advanced concepts relating to how Polynote works. Certain topics are important enough to warrant their own pages; see them in the sidebar on the left. Stopping \u00b6 All the Stop buttons found in various places in the UI generally do the same thing - they send an interrupt signal to the current thing being executed by Polynote - whether that \"thing\" is a kernel launching, dependency download, or cell execution.","title":"Advanced"},{"location":"docs/advanced/#stopping","text":"All the Stop buttons found in various places in the UI generally do the same thing - they send an interrupt signal to the current thing being executed by Polynote - whether that \"thing\" is a kernel launching, dependency download, or cell execution.","title":"Stopping"},{"location":"docs/basic-usage/","text":"Basic usage \u00b6 Info This page aims to get you up and running with your first Polynote notebook. For a more in-depth walk through the Polynote user interface, check out the Tour . After starting Polynote and opening the application in your browser at http://localhost:8192/ you'll see the home page. On the left is the list of notebook files. If you have just installed Polynote, the only notebooks you will have access to are our examples. Feel free to browse these notebooks for your future reference. Creating a new notebook \u00b6 For now, though, we'll just jump right into creating a new notebook. Click the \"New notebook\" button (left), and a dialog will come up (right). Enter a name for your notebook and then click \"Create\". The new notebook appears in the Notebooks List \u2460 , and is opened in a Polynote tab \u2461 with the Configuration Pane open \u2462 . We'll ignore the configuration for now, so click anywhere on the \u25bc Configuration & dependencies heading \u2463 to close it. You'll see that the notebook contains a single text cell. Click on that cell and you'll see the text editing toolbar appear (shown boxed in the image below). This contextual toolbar appears when it's useful, based on the currently active cell. You'll see it change as you interact with cells of various types. Check out the tour for a more comprehensive breakdown of the toolbar and the different cell types. Creating a new cell \u00b6 A notebook document is made up of a collection of cells. Currently, Polynote supports three cell types: text cells, code cells, and visualization (viz) cells. Text cells are useful for writing rich text explanations, code cells contain the code that actually gets run in the notebook, and viz cells aid in inspecting and visualizing data. Now that we've seen a text cell, let's create a new code cell. If you hover the mouse above and below the text cell, you'll see a divider appear with a small + symbol. Clicking on that divider will create a new cell in its place. Go ahead and click on the divider below the text cell to create a new cell there. This new cell is a code cell, with its language (by default) set to Scala. You can change the language with the dropdown \u2013 there's one right above the cell and one on the main toolbar. If you wanted another text cell instead, you can change it to Text as well (but only in the dropdown on the main toolbar) and it will turn into a text cell. Let's enter some Scala code in the code cell. The code we're writing is just a little snippet for demonstration purposes. Here it is in case you're following along: Demonstation Code import scala . util . Random . nextGaussian println ( \"this is some console output!\" ) val x = 50 case class Point ( x : Double , y : Double ) List . fill ( x )( Point ( nextGaussian * 2 + 5 , nextGaussian * 4 )) Once you start typing, you'll see some activity under Tasks on the right as the Kernel is started. The Kernel is what handles computing the notebook code, including providing code completions and suggestions. Once it starts, you'll start seeing interactive completions as you type. Run the code cell by pressing Shift + Enter . The cell runs, and output is displayed. Here's what you should see: Let's take a closer look at the results of running the cell. We can see that a few things happened after running the code: The console output from the println statement appeared in an area \u2460 below the cell. The variable x defined in the cell appeared in the Symbol Table \u2461 on the right. The final expression of the cell was bound to a variable called Out \u2462 and some information about it appeared below the console output \u2463 . Because the expression List . fill ( 50 )( Point ( nextGaussian * 2 + 5 , nextGaussian * 4 )) results in \"table-like\" data \u2013 a collection of structured values \u2013 a special representation of it is displayed. In this Cell Result view, we can see the result's schema (the fields of the structured row) along with its type and some icons. Clicking these icons creates a new viz cell below this one, allowing you to inspect the cell's result in more detail. In addition to inspecting the \"result\" of the cell, any other value that's been bound to a variable can be inspected by clicking it in the Symbol Table. We'll now take a closer look at the Symbol Table, and how it changes as you interact with the notebook. The Symbol Table and input scope \u00b6 If you create and run some more code cells, you'll notice that the Symbol Table changes depending on which cell is currently focused. It shows you any values that resulted from the current cell above a thick black line, and any values that are available to the cell (from previous cells) below the thick black line. In the image above, you can see how the Symbol Table changes based on which cell is selected. This allows you to keep track of which variables are available, which is useful because Polynote keeps track of the cell input scope. Polynote is different from other notebook tools in that a cell's place in the notebook is important. Every cell has an \"input state\" defined by the cells that have run above it. This means that if we create a code cell that defines a value: val foo = 20 Then another cell below it can use the value foo : val bar = foo * 2 But, if we then go back and edit the first cell like this: val foo = 20 val fail = bar * 2 It won't work! The value bar isn't in the input scope of the first cell, because it was defined in the second cell. This is very different from how other notebook tools operate; they just have one global state that every cell mutates. In Polynote, the input state of a cell is defined completely by which cells are above it. This is a powerful way to enforce reproducibility in a notebook; it is far more likely that you'll be able to re-run the notebook from top to bottom if later cells can't affect earlier cells. Here's an example of the above scenario in practice (reordering the cells rather than editing their content): Next, read about mixing programming languages .","title":"Basic Usage"},{"location":"docs/basic-usage/#basic-usage","text":"Info This page aims to get you up and running with your first Polynote notebook. For a more in-depth walk through the Polynote user interface, check out the Tour . After starting Polynote and opening the application in your browser at http://localhost:8192/ you'll see the home page. On the left is the list of notebook files. If you have just installed Polynote, the only notebooks you will have access to are our examples. Feel free to browse these notebooks for your future reference.","title":"Basic usage"},{"location":"docs/basic-usage/#creating-a-new-notebook","text":"For now, though, we'll just jump right into creating a new notebook. Click the \"New notebook\" button (left), and a dialog will come up (right). Enter a name for your notebook and then click \"Create\". The new notebook appears in the Notebooks List \u2460 , and is opened in a Polynote tab \u2461 with the Configuration Pane open \u2462 . We'll ignore the configuration for now, so click anywhere on the \u25bc Configuration & dependencies heading \u2463 to close it. You'll see that the notebook contains a single text cell. Click on that cell and you'll see the text editing toolbar appear (shown boxed in the image below). This contextual toolbar appears when it's useful, based on the currently active cell. You'll see it change as you interact with cells of various types. Check out the tour for a more comprehensive breakdown of the toolbar and the different cell types.","title":"Creating a new notebook"},{"location":"docs/basic-usage/#creating-a-new-cell","text":"A notebook document is made up of a collection of cells. Currently, Polynote supports three cell types: text cells, code cells, and visualization (viz) cells. Text cells are useful for writing rich text explanations, code cells contain the code that actually gets run in the notebook, and viz cells aid in inspecting and visualizing data. Now that we've seen a text cell, let's create a new code cell. If you hover the mouse above and below the text cell, you'll see a divider appear with a small + symbol. Clicking on that divider will create a new cell in its place. Go ahead and click on the divider below the text cell to create a new cell there. This new cell is a code cell, with its language (by default) set to Scala. You can change the language with the dropdown \u2013 there's one right above the cell and one on the main toolbar. If you wanted another text cell instead, you can change it to Text as well (but only in the dropdown on the main toolbar) and it will turn into a text cell. Let's enter some Scala code in the code cell. The code we're writing is just a little snippet for demonstration purposes. Here it is in case you're following along: Demonstation Code import scala . util . Random . nextGaussian println ( \"this is some console output!\" ) val x = 50 case class Point ( x : Double , y : Double ) List . fill ( x )( Point ( nextGaussian * 2 + 5 , nextGaussian * 4 )) Once you start typing, you'll see some activity under Tasks on the right as the Kernel is started. The Kernel is what handles computing the notebook code, including providing code completions and suggestions. Once it starts, you'll start seeing interactive completions as you type. Run the code cell by pressing Shift + Enter . The cell runs, and output is displayed. Here's what you should see: Let's take a closer look at the results of running the cell. We can see that a few things happened after running the code: The console output from the println statement appeared in an area \u2460 below the cell. The variable x defined in the cell appeared in the Symbol Table \u2461 on the right. The final expression of the cell was bound to a variable called Out \u2462 and some information about it appeared below the console output \u2463 . Because the expression List . fill ( 50 )( Point ( nextGaussian * 2 + 5 , nextGaussian * 4 )) results in \"table-like\" data \u2013 a collection of structured values \u2013 a special representation of it is displayed. In this Cell Result view, we can see the result's schema (the fields of the structured row) along with its type and some icons. Clicking these icons creates a new viz cell below this one, allowing you to inspect the cell's result in more detail. In addition to inspecting the \"result\" of the cell, any other value that's been bound to a variable can be inspected by clicking it in the Symbol Table. We'll now take a closer look at the Symbol Table, and how it changes as you interact with the notebook.","title":"Creating a new cell"},{"location":"docs/basic-usage/#the-symbol-table-and-input-scope","text":"If you create and run some more code cells, you'll notice that the Symbol Table changes depending on which cell is currently focused. It shows you any values that resulted from the current cell above a thick black line, and any values that are available to the cell (from previous cells) below the thick black line. In the image above, you can see how the Symbol Table changes based on which cell is selected. This allows you to keep track of which variables are available, which is useful because Polynote keeps track of the cell input scope. Polynote is different from other notebook tools in that a cell's place in the notebook is important. Every cell has an \"input state\" defined by the cells that have run above it. This means that if we create a code cell that defines a value: val foo = 20 Then another cell below it can use the value foo : val bar = foo * 2 But, if we then go back and edit the first cell like this: val foo = 20 val fail = bar * 2 It won't work! The value bar isn't in the input scope of the first cell, because it was defined in the second cell. This is very different from how other notebook tools operate; they just have one global state that every cell mutates. In Polynote, the input state of a cell is defined completely by which cells are above it. This is a powerful way to enforce reproducibility in a notebook; it is far more likely that you'll be able to re-run the notebook from top to bottom if later cells can't affect earlier cells. Here's an example of the above scenario in practice (reordering the cells rather than editing their content): Next, read about mixing programming languages .","title":"The Symbol Table and input scope"},{"location":"docs/code-cells/","text":"Code cells are the basic unit of a notebook interactive coding experience. In addition to providing a code editor, code cells show the output and results of executing the code. The top of a code cell has a small toolbar of cell-related functions: a button to run the cell, a drop-down for switching languages, buttons for hiding the code or output and a button to copy output to the clipboard (if present). Code Editing \u00b6 Polynote provides a modern code editing experience (interactive autocomplete, error highlighting) built with the Monaco Editor . Cell Results \u00b6 The last expression in a cell is treated as its result (just as a Scala function returns the result of the last expression). This result is saved as the Out variable and is displayed in the cell's result section. Polynote just shows the value and simple type of simple results. For more complex results, Polynote shows a data view that allows more inspection of the data. Nested Data \u00b6 Nested data can be explored directly in a tree-like view. Exploring Nested Data Source Code case class A ( foo : String ) case class B ( bar : String , a : List [ A ]) case class C ( quux : String , b : List [ B ]) case class D ( wizzle : String , c : List [ C ]) case class E ( wozzle : String , d : List [ D ]) E ( \"wozzle\" , D ( \"wizzle\" , C ( \"quux\" , B ( \"bar\" , A ( \"foo\" ) :: A ( \"floo\" ) :: Nil ) :: Nil ) :: Nil ) :: D ( \"weasel\" , C ( \"quacks\" , Nil ) :: Nil ) :: Nil ) Inspecting Results \u00b6 Like the buttons in the Quick Inspector , the View Data , View Schema , and Plot Data buttons each create a new Viz Cell underneath the cell.","title":"Code Cells"},{"location":"docs/code-cells/#code-editing","text":"Polynote provides a modern code editing experience (interactive autocomplete, error highlighting) built with the Monaco Editor .","title":"Code Editing"},{"location":"docs/code-cells/#cell-results","text":"The last expression in a cell is treated as its result (just as a Scala function returns the result of the last expression). This result is saved as the Out variable and is displayed in the cell's result section. Polynote just shows the value and simple type of simple results. For more complex results, Polynote shows a data view that allows more inspection of the data.","title":"Cell Results"},{"location":"docs/code-cells/#nested-data","text":"Nested data can be explored directly in a tree-like view. Exploring Nested Data Source Code case class A ( foo : String ) case class B ( bar : String , a : List [ A ]) case class C ( quux : String , b : List [ B ]) case class D ( wizzle : String , c : List [ C ]) case class E ( wozzle : String , d : List [ D ]) E ( \"wozzle\" , D ( \"wizzle\" , C ( \"quux\" , B ( \"bar\" , A ( \"foo\" ) :: A ( \"floo\" ) :: Nil ) :: Nil ) :: Nil ) :: D ( \"weasel\" , C ( \"quacks\" , Nil ) :: Nil ) :: Nil )","title":"Nested Data"},{"location":"docs/code-cells/#inspecting-results","text":"Like the buttons in the Quick Inspector , the View Data , View Schema , and Plot Data buttons each create a new Viz Cell underneath the cell.","title":"Inspecting Results"},{"location":"docs/development/","text":"sbt dist","title":"Developing with Polynote"},{"location":"docs/docker/","text":"","title":"Using Polynote with Docker"},{"location":"docs/faq/","text":"","title":"FAQ"},{"location":"docs/installation/","text":"Installing Polynote \u00b6 Danger Polynote allows arbitrary remote code execution , which is necessary for a notebook tool to function. While we'll try to improve safety by adding security measures, it will never be completely safe to run Polynote on your personal computer. For example: It's possible that other websites you visit could use Polynote as an attack vector. Browsing the web while running Polynote is unsafe. It's possible that remote attackers could use Polynote as an attack vector. Running Polynote on a computer that's accessible from the internet is unsafe. Even running Polynote inside a container doesn't guarantee safety, as there will always be privilege escalation and container escape vulnerabilities which an attacker could leverage. Please be diligent about checking for new releases, as they could contain fixes for critical security flaws. Please be mindful of the security issues that Polynote causes; consult your company's security team before running Polynote. You are solely responsible for any breach, loss, or damage caused by running this software insecurely. Polynote is currently only tested on Linux and MacOS, using the Chrome browser as a client. While we'd love it if Polynote would work perfectly on other platforms and browsers, our small team doesn't have the bandwidth to test every possible combination. Feel free to try it on your platform, and be sure to let us know about any issues you encounter by filing a bug report. What about Firefox? While we don't test with Firefox, we are very interested in making sure that Firefox is a viable alternative to Chrome when using Polynote. Right now, we're in need of Firefox users who can provide us with bug reports (and, ideally, bug fixes too!), so please do let us know if you run into issues using Firefox! What about Windows? Some users have reported that Polynote runs successfully on Windows Subsystem for Linux. We have no plans to support Windows outside of the WSL. Please see these issues for more information: #555 , #671 . Using Polynote with Docker Instead of installing Polynote on your computer, you can run it within a Docker container. This is a good way to get up and running quickly, though properly configuring the networking settings so a Docker container running on your laptop can access a remote Spark cluster can be a bit tricky. For more information about using Docker to run Polynote, see the Polynote Docker docs . Prerequisites \u00b6 Polynote has been successfully tested on both Java 8 and Java 11. Spark support \u00b6 In order to use Apache Spark\u2122 with Polynote, you'll need to have it set up in your environment. Using Spark with Polynote If you'll be using Spark with Polynote, please make sure you read this note about Spark and Polynote for more information. Currently, Polynote supports both Spark 2.1 (with Scala 2.11) and 2.4 (with Scala 2.11 and 2.12). Some users have had success running Spark 3.0 with Scala 2.12. Please see this issue for more information Polynote will use the spark-submit command in order to start Spark kernels. The spark-submit command must be working properly and available on the PATH of the environment you used to launch the server in order for Polynote to work properly with Spark. Installing Spark in your environment These instructions are provided as a convenience, but please note that versions and environments differ. Please refer to the official documentation or other online resources if you run into trouble setting up Spark. As mentioned above, Polynote just needs spark-submit to be working correctly and available on the PATH in the environment in which it is running. It doesn't matter how you install Spark as long as those two things are true. Standard Spark installation The \"standard\" way to install Spark is just to extract the distribution somewhere and then set up some environment variables. This method works for on both Mac and Linux. You may need to modify these instructions based on your local setup. Spark on Mac Here is an example setup for Polynote on Mac. Also, check out the \"Installation with Homebrew\" tab above for an alternative installation method. Install Java (this installs Java 11) brew cask install adoptopenjdk11 Download spark and then untar it wherever you like tar -zxvf spark-2.4.7-bin-hadoop2.7.tgz Set up the SPARK_HOME and PATH environment variables. You probably want to put these instructions in your shell configuration somewhere, i.e., ~/.bashrc or equivalent. Set SPARK_HOME export SPARK_HOME=`pwd`/spark-2.4.7-bin-hadoop2.7/ Set PATH export PATH=\"$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin\" Check if Spark is correctly set up by running spark-submit , you should see usage information. Spark on Linux Here is an example setup for Polynote on Debian. If you are not using Debian or Ubuntu, you may need to modify these instructions for your distribution. As always, start with updating your package listing. apt-get update Install Java (this installs Java 11 for me on Debian buster) apt-get install default-jdk Download spark and then untar it wherever you like tar -zxvf spark-2.4.4-bin-hadoop2.7.tgz Set up the JAVA_HOME , SPARK_HOME and PATH environment variables. You probably want to put these instructions in your shell configuration somewhere, i.e., ~/.bashrc or equivalent. Set JAVA_HOME export JAVA_HOME=/usr/lib/jvm/default-java/ Set SPARK_HOME export SPARK_HOME=`pwd`/spark-2.4.7-bin-hadoop2.7/ Set PATH export PATH=\"$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin\" Check if Spark is correctly set up by running spark-submit , you should see usage information. Installing Spark on Mac with Homebrew The Homebrew package manager for Mac has a formula for Spark , but unfortunately it only installs the latest version which may not be compatible with Polynote. Installing an older version of Spark using Homebrew can be a bit of a pain. There is a third party repository that has older Spark versions available for easy download. Warning It is highly recommended that you read through the homebrew formula before installing it - especially when using a third-party repository. The entire thing is less than 30 lines of Ruby code and quite readable. You can view the available formulae here: https://github.com/eddies/homebrew-spark-tap/tree/master/Formula Here's an example for Spark 2.4: brew tab eddies/spark-tap brew install apache-spark@2.4.6 Python support \u00b6 In order to run Polynote, you'll need to have a working Python 3 environment (including pip ) installed. Refer to Python's installation instructions for instructions. Using Python with Polynote Polynote officially supports Python 3.7 . This is the version of Python supported by the Spark versions we're targeting. Users have reported getting it to work with Python 3.6 and Python 3.8 (without Spark) with minimal effort. You'll also need to install Polynote's Python dependencies: pip install -r ./requirements.txt Download \u00b6 Polynote consists of a JVM-based server application, which serves a web-based client. To try it locally, find the latest release on the releases page and download the attached polynote-dist.tar.gz file (you'll find it under Assets ). Unpack the archive: tar -zxvpf polynote-dist.tar.gz cd polynote Configure \u00b6 You won't need to change any of the default configuration in order to get Polynote up and running locally. Please see the configuration documentation for more details on configuring Polynote. Run \u00b6 To start the server, run the included python script: ./polynote.py Once the server has started, navigate your browser to http://localhost:8192 (if using the default network configuration).","title":"Installation"},{"location":"docs/installation/#installing-polynote","text":"Danger Polynote allows arbitrary remote code execution , which is necessary for a notebook tool to function. While we'll try to improve safety by adding security measures, it will never be completely safe to run Polynote on your personal computer. For example: It's possible that other websites you visit could use Polynote as an attack vector. Browsing the web while running Polynote is unsafe. It's possible that remote attackers could use Polynote as an attack vector. Running Polynote on a computer that's accessible from the internet is unsafe. Even running Polynote inside a container doesn't guarantee safety, as there will always be privilege escalation and container escape vulnerabilities which an attacker could leverage. Please be diligent about checking for new releases, as they could contain fixes for critical security flaws. Please be mindful of the security issues that Polynote causes; consult your company's security team before running Polynote. You are solely responsible for any breach, loss, or damage caused by running this software insecurely. Polynote is currently only tested on Linux and MacOS, using the Chrome browser as a client. While we'd love it if Polynote would work perfectly on other platforms and browsers, our small team doesn't have the bandwidth to test every possible combination. Feel free to try it on your platform, and be sure to let us know about any issues you encounter by filing a bug report. What about Firefox? While we don't test with Firefox, we are very interested in making sure that Firefox is a viable alternative to Chrome when using Polynote. Right now, we're in need of Firefox users who can provide us with bug reports (and, ideally, bug fixes too!), so please do let us know if you run into issues using Firefox! What about Windows? Some users have reported that Polynote runs successfully on Windows Subsystem for Linux. We have no plans to support Windows outside of the WSL. Please see these issues for more information: #555 , #671 . Using Polynote with Docker Instead of installing Polynote on your computer, you can run it within a Docker container. This is a good way to get up and running quickly, though properly configuring the networking settings so a Docker container running on your laptop can access a remote Spark cluster can be a bit tricky. For more information about using Docker to run Polynote, see the Polynote Docker docs .","title":"Installing Polynote"},{"location":"docs/installation/#prerequisites","text":"Polynote has been successfully tested on both Java 8 and Java 11.","title":"Prerequisites"},{"location":"docs/installation/#spark-support","text":"In order to use Apache Spark\u2122 with Polynote, you'll need to have it set up in your environment. Using Spark with Polynote If you'll be using Spark with Polynote, please make sure you read this note about Spark and Polynote for more information. Currently, Polynote supports both Spark 2.1 (with Scala 2.11) and 2.4 (with Scala 2.11 and 2.12). Some users have had success running Spark 3.0 with Scala 2.12. Please see this issue for more information Polynote will use the spark-submit command in order to start Spark kernels. The spark-submit command must be working properly and available on the PATH of the environment you used to launch the server in order for Polynote to work properly with Spark. Installing Spark in your environment These instructions are provided as a convenience, but please note that versions and environments differ. Please refer to the official documentation or other online resources if you run into trouble setting up Spark. As mentioned above, Polynote just needs spark-submit to be working correctly and available on the PATH in the environment in which it is running. It doesn't matter how you install Spark as long as those two things are true. Standard Spark installation The \"standard\" way to install Spark is just to extract the distribution somewhere and then set up some environment variables. This method works for on both Mac and Linux. You may need to modify these instructions based on your local setup. Spark on Mac Here is an example setup for Polynote on Mac. Also, check out the \"Installation with Homebrew\" tab above for an alternative installation method. Install Java (this installs Java 11) brew cask install adoptopenjdk11 Download spark and then untar it wherever you like tar -zxvf spark-2.4.7-bin-hadoop2.7.tgz Set up the SPARK_HOME and PATH environment variables. You probably want to put these instructions in your shell configuration somewhere, i.e., ~/.bashrc or equivalent. Set SPARK_HOME export SPARK_HOME=`pwd`/spark-2.4.7-bin-hadoop2.7/ Set PATH export PATH=\"$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin\" Check if Spark is correctly set up by running spark-submit , you should see usage information. Spark on Linux Here is an example setup for Polynote on Debian. If you are not using Debian or Ubuntu, you may need to modify these instructions for your distribution. As always, start with updating your package listing. apt-get update Install Java (this installs Java 11 for me on Debian buster) apt-get install default-jdk Download spark and then untar it wherever you like tar -zxvf spark-2.4.4-bin-hadoop2.7.tgz Set up the JAVA_HOME , SPARK_HOME and PATH environment variables. You probably want to put these instructions in your shell configuration somewhere, i.e., ~/.bashrc or equivalent. Set JAVA_HOME export JAVA_HOME=/usr/lib/jvm/default-java/ Set SPARK_HOME export SPARK_HOME=`pwd`/spark-2.4.7-bin-hadoop2.7/ Set PATH export PATH=\"$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin\" Check if Spark is correctly set up by running spark-submit , you should see usage information. Installing Spark on Mac with Homebrew The Homebrew package manager for Mac has a formula for Spark , but unfortunately it only installs the latest version which may not be compatible with Polynote. Installing an older version of Spark using Homebrew can be a bit of a pain. There is a third party repository that has older Spark versions available for easy download. Warning It is highly recommended that you read through the homebrew formula before installing it - especially when using a third-party repository. The entire thing is less than 30 lines of Ruby code and quite readable. You can view the available formulae here: https://github.com/eddies/homebrew-spark-tap/tree/master/Formula Here's an example for Spark 2.4: brew tab eddies/spark-tap brew install apache-spark@2.4.6","title":"Spark support"},{"location":"docs/installation/#python-support","text":"In order to run Polynote, you'll need to have a working Python 3 environment (including pip ) installed. Refer to Python's installation instructions for instructions. Using Python with Polynote Polynote officially supports Python 3.7 . This is the version of Python supported by the Spark versions we're targeting. Users have reported getting it to work with Python 3.6 and Python 3.8 (without Spark) with minimal effort. You'll also need to install Polynote's Python dependencies: pip install -r ./requirements.txt","title":"Python support"},{"location":"docs/installation/#download","text":"Polynote consists of a JVM-based server application, which serves a web-based client. To try it locally, find the latest release on the releases page and download the attached polynote-dist.tar.gz file (you'll find it under Assets ). Unpack the archive: tar -zxvpf polynote-dist.tar.gz cd polynote","title":"Download"},{"location":"docs/installation/#configure","text":"You won't need to change any of the default configuration in order to get Polynote up and running locally. Please see the configuration documentation for more details on configuring Polynote.","title":"Configure"},{"location":"docs/installation/#run","text":"To start the server, run the included python script: ./polynote.py Once the server has started, navigate your browser to http://localhost:8192 (if using the default network configuration).","title":"Run"},{"location":"docs/kernel-pane/","text":"The Kernel Pane displays information about the running state of the active notebook's kernel. The Header , which shows the current status of the kernel and controls for starting and stopping it. The Info section, which shows information about the current kernel. The Symbol Table , which shows the state of the kernel for the currently-selected cell. The Tasks section, which shows what the kernel is currently doing. Header \u00b6 The colored circle to the left of the header shows the status of the Kernel. Possible statuses are: Color Meaning Example Gray The client is disconnected from Polynote 1 Red The kernel is stopped : connected but not running Yellow The kernel is busy executing something Green The kernel is running and idle This means that the browser is unable to talk to the Polynote server. The server might be down, or there might be a connection issue between the browser and Polynote. You might have also noticed that the symbol on the right side of the header changes depending on the kernel's status. This symbol is a button that allows you to interact with the kernel: Button State Available Action stopped Launch the kernel busy , idle Kill the kernel disconnected Attempt to reconnect to the server Info \u00b6 The Info section contains information about a currently running Kernel. Currently, standard kernels simply display the current Polynote version, as well as the build commit. Tip Use the version and commit information when reporting issues to the Polynote team! In addition to the above, Spark kernels show a link to the current Spark UI. Symbol Table \u00b6 The Symbol Table reveals the current state of the notebook, showing the input and output symbols of the currently selected cell (provided that the cell has been run). See the Basic Usage section for a simple example of the symbol table. The symbol table displayes the names and types of the available symbols. In order to see the value of the symbols and to inspect them further, you can hover over them to reveal the Quick Inspector. Quick Inspector \u00b6 In the above example, the selected cell has been run, so the symbols defined within are visible in the symbol table. Hovering over each symbol reveals the Quick Inspector. For the data variable, a simple Seq [( String , String )] , the Quick Inspector shows the entire toString() value. However, as Out is a DataFrame , only the schema is shown as Polynote evaluates it lazily to prevent collecting huge data unnecessarily. Let's take a closer look at the Quick Inspector. The first three buttons - View Data , View Schema , and Plot Data , each create a new Viz Cell underneath the cell that defined the symbol, with the appropriate tab selected. The last button, the magnifying glass, creates a modal that shows the available representations of the output. Tasks \u00b6 The Tasks section exposes information about what the kernel is doing: current and queued executions, as well as errors that might come up that are not associated with a particular cell. Currently Running Tasks \u00b6 In the above example, a cell that contains Spark code is being executed, while the cell below it is queued up. On the Tasks section, the current state of the execution is shown: the top task is labeled with the currently-running cell's ID, as well as a label reflecting the statement being executed currently - in this case, the sparkComputation variable being computed; in other cases a line number might be shown. Since the execution is a Spark job, an additional task is shown, showing details of the Spark execution: the job number and a label for the currently-executing stage (in this case, the call to collect() ). Finally, task is generated for the queued cell that will be executed after this one is finished. The tasks list always shows the order in which cells will be executed. Tip Note the Stop button on the top-right corner, which can be used to stop the currently-running task. It behaves like the other stop buttons in the UI; for more details, please see the advanced documentation . Kernel or Server-level Errors \u00b6 The Tasks section also provides a location to display error messages that don't belong to a specific cell. For example, you might see errors encountered during dependency resolution, or kernel crashes, or connection issues.","title":"Kernel Pane"},{"location":"docs/kernel-pane/#header","text":"The colored circle to the left of the header shows the status of the Kernel. Possible statuses are: Color Meaning Example Gray The client is disconnected from Polynote 1 Red The kernel is stopped : connected but not running Yellow The kernel is busy executing something Green The kernel is running and idle This means that the browser is unable to talk to the Polynote server. The server might be down, or there might be a connection issue between the browser and Polynote. You might have also noticed that the symbol on the right side of the header changes depending on the kernel's status. This symbol is a button that allows you to interact with the kernel: Button State Available Action stopped Launch the kernel busy , idle Kill the kernel disconnected Attempt to reconnect to the server","title":"Header"},{"location":"docs/kernel-pane/#info","text":"The Info section contains information about a currently running Kernel. Currently, standard kernels simply display the current Polynote version, as well as the build commit. Tip Use the version and commit information when reporting issues to the Polynote team! In addition to the above, Spark kernels show a link to the current Spark UI.","title":"Info"},{"location":"docs/kernel-pane/#symbol-table","text":"The Symbol Table reveals the current state of the notebook, showing the input and output symbols of the currently selected cell (provided that the cell has been run). See the Basic Usage section for a simple example of the symbol table. The symbol table displayes the names and types of the available symbols. In order to see the value of the symbols and to inspect them further, you can hover over them to reveal the Quick Inspector.","title":"Symbol Table"},{"location":"docs/kernel-pane/#quick-inspector","text":"In the above example, the selected cell has been run, so the symbols defined within are visible in the symbol table. Hovering over each symbol reveals the Quick Inspector. For the data variable, a simple Seq [( String , String )] , the Quick Inspector shows the entire toString() value. However, as Out is a DataFrame , only the schema is shown as Polynote evaluates it lazily to prevent collecting huge data unnecessarily. Let's take a closer look at the Quick Inspector. The first three buttons - View Data , View Schema , and Plot Data , each create a new Viz Cell underneath the cell that defined the symbol, with the appropriate tab selected. The last button, the magnifying glass, creates a modal that shows the available representations of the output.","title":"Quick Inspector"},{"location":"docs/kernel-pane/#tasks","text":"The Tasks section exposes information about what the kernel is doing: current and queued executions, as well as errors that might come up that are not associated with a particular cell.","title":"Tasks"},{"location":"docs/kernel-pane/#currently-running-tasks","text":"In the above example, a cell that contains Spark code is being executed, while the cell below it is queued up. On the Tasks section, the current state of the execution is shown: the top task is labeled with the currently-running cell's ID, as well as a label reflecting the statement being executed currently - in this case, the sparkComputation variable being computed; in other cases a line number might be shown. Since the execution is a Spark job, an additional task is shown, showing details of the Spark execution: the job number and a label for the currently-executing stage (in this case, the call to collect() ). Finally, task is generated for the queued cell that will be executed after this one is finished. The tasks list always shows the order in which cells will be executed. Tip Note the Stop button on the top-right corner, which can be used to stop the currently-running task. It behaves like the other stop buttons in the UI; for more details, please see the advanced documentation .","title":"Currently Running Tasks"},{"location":"docs/kernel-pane/#kernel-or-server-level-errors","text":"The Tasks section also provides a location to display error messages that don't belong to a specific cell. For example, you might see errors encountered during dependency resolution, or kernel crashes, or connection issues.","title":"Kernel or Server-level Errors"},{"location":"docs/mixing-programming-languages/","text":"One of Polynote's most interesting features is its support for polyglot notebooks, where cells within the same notebook can be written in different languages. Variables can also be shared across languages, as all execution is done within a single process. Execution state in Polynote \u00b6 We hinted previously that the way Polynote handles cell execution is a little special. As a reminder, the kernel keeps track of all the symbols defined by a cell execution. These symbols are part of the cell's state, which is made available to downstream cells (those below the cell in question) when they in turn are executed. Polynote stores these symbols, alongside their types and other information, in a Scala-based format. Symbols defined by and provided to other languages are wrapped (and unwrapped) appropriately. For more details, how this works under the hood, and information about its limitations and caveats, check out the Python documentation . Polyglot example \u00b6 Continuing our example notebook from before , here's a trivial example (note that the bottom cell has Python selected in the language drop-down). The foo and bar Scala variables can be accessed directly in Python, because they represent primitive types ( Int s in this case). This also works the other way 'round, from Python to Scala, in much the same way. Use Case: Plotting Scala data with Matplotlib \u00b6 Real-world usage at Netflix This example notebook illustrates a contrived version of a common use-case at Netflix. Our recommendation and personalization infrastructure is heavily JVM-based , and Algorithm Engineers and Scientists want to interface with our platform in order to, for example: transform data in a type-safe way using Scala access Model Lifecycle data generate features based on online data snapshots Once they get the data, they'd like to analyze and visualize it using the Python tools they are familiar with, such as pandas and matplotlib . A more complex example of a more typical usage can be found in the examples/ folder in Plotting Scala data with Matplotlib.ipynb which is reproduced below. We'll go over this example in detail. A direct approach using primitives \u00b6 This notebook takes a direct approach to polyglot development. By crossing language boundaries using primitive data structures, you don't need to worry about the details of language-specific data structures or implementations. Let's go over this notebook, which consists of two cells. The first, a Scala cell, prepares some data, while the second, a Python cell, plots it. Scala cell val colors = Array ( \"red\" , \"green\" , \"blue\" ) val n = 750 val flattenedLength = colors . length * n * 2 // 2 for x and y val data = ( 0 until flattenedLength ). map ( _ => Math . random ()). toArray // converted to Array for Python interop This cell generates an Array [ Double ] that is a flattened representation of data in three dimensions - color , x , and y . This data is then fed into the Python cell to be plotted: Python cell import matplotlib.pyplot as plt from numpy.random import rand fig , ax = plt . subplots () for color in colors : # since data is just a 1-D array we need to split it up to fit the matplotlib example x = data [: n ] data = data [ n :] y = data [: n ] data = data [ n :] scale = 200.0 * rand ( n ) ax . scatter ( x , y , c = color , s = scale , label = color , alpha = 0.3 , edgecolors = 'none' ) ax . legend () ax . grid ( True ) plt . show () This cell steps through the data array and, for each color , unflattens the x and y data for plotting (note that both data and color are Scala variables accessed directly from Python). Can we do better? \u00b6 This is pretty straightforward, but you might have noticed that the interchange values between the two languages are Array s, rather than the more idiomatic (for Scala) Seq s. You might also notice that it was pretty unnatural to flatten data like we did. The reason for this is that it's easier to interchange between Scala and Python using primitives and basic structures like Arrays. You might not realize it, but when you work with Scala there's all sorts of stuff going on behind the scenes, such as implicits, or encoded Java method names (like $colon$colon() ). Python doesn't know about this, so when we interact with a Scala object from Python we see it in all its gory details: However, with a little Scala knowledge we can rewrite the plotting code to be more idiomatic, at the expense of having to do (a bit) more work in Python to massage the data. A more idiomatic implementation \u00b6 First, we'll use some more idiomatic code to generate our point data: case class Point ( x : Double , y : Double , color : String ) val colors = Seq ( \"red\" , \"green\" , \"blue\" ) val n = 750 val idiomaticData = for { color <- colors n <- ( 0 to n ) } yield Point ( Math . random (), Math . random (), color ) Wow, a case class AND a for expression? This is surely extremely idiomatic Scala code. Not an Array in sight! Let's inspect idiomaticData for a moment. Inspecting and Visualizing Data This image showcases using the Quick Inspector and Viz cells to easily inspect values within a notebook. Now that we've taken a look at idiomaticData and seen that it's a Seq [ Point ] , we can delete the Viz cell and start working with it using Python. Since we're no longer working with primitives, we need to do a little data preparation. We'll build a list , iterate over idiomaticData , and extract values from Point . We want to end up with a simple 2D-Array we can use with matplotlib . data = [] for idx in range ( 0 , idiomaticData . length ()): point = idiomaticData . apply ( idx ) data . append ([ point . x (), point . y (), point . color ()]) There are two things of note here. First, we need to manually iterate through the collection, generating an index which we can pass into the apply ( idx : Int ): A method of the Seq to select elements from it. Second, we'll access the case class members using the member accessor methods as usual, but note that with Python we need to specify () , as in point . x () , since of course in Python parentheses are always required, even for nullary functions (ones that have no arguments). At this point, the data variable is a nice list of list s, and we can easily turn it into a Pandas DataFrame: import pandas as pd df = pd . DataFrame ( data = data , columns = [ 'x' , 'y' , 'color' ]) Note that we have to manually specify the column names here. A more advanced example might extract the fields from Point and pass them into Python, but we'll pass on that for now. Now that our data is a Pandas DataFrame we can manipulate it as usual. For example, we can add a scale column to it: import numpy as np df [ 'scale' ] = np . random . uniform ( 1 , 200 , df . shape [ 0 ]) Finally, we can plot our DataFrame in the familiar way. import matplotlib.pyplot as plt fig , ax = plt . subplots () groups = df . groupby ( \"color\" ) for name , group in groups : ax . scatter ( group . x , group . y , c = group . color , s = group . scale , label = name , alpha = 0.3 , edgecolors = 'none' ) ax . legend ( loc = \"upper right\" ) ax . grid ( True ) plt . show () That's it! This notebook can be found in the examples/ folder as well, in Plotting Scala data with Matplotlib (Idiomatic).ipynb . You can see a screenshot below. Next, read about using Spark with Polynote .","title":"Mixing Programming Languages"},{"location":"docs/mixing-programming-languages/#execution-state-in-polynote","text":"We hinted previously that the way Polynote handles cell execution is a little special. As a reminder, the kernel keeps track of all the symbols defined by a cell execution. These symbols are part of the cell's state, which is made available to downstream cells (those below the cell in question) when they in turn are executed. Polynote stores these symbols, alongside their types and other information, in a Scala-based format. Symbols defined by and provided to other languages are wrapped (and unwrapped) appropriately. For more details, how this works under the hood, and information about its limitations and caveats, check out the Python documentation .","title":"Execution state in Polynote"},{"location":"docs/mixing-programming-languages/#polyglot-example","text":"Continuing our example notebook from before , here's a trivial example (note that the bottom cell has Python selected in the language drop-down). The foo and bar Scala variables can be accessed directly in Python, because they represent primitive types ( Int s in this case). This also works the other way 'round, from Python to Scala, in much the same way.","title":"Polyglot example"},{"location":"docs/mixing-programming-languages/#use-case-plotting-scala-data-with-matplotlib","text":"Real-world usage at Netflix This example notebook illustrates a contrived version of a common use-case at Netflix. Our recommendation and personalization infrastructure is heavily JVM-based , and Algorithm Engineers and Scientists want to interface with our platform in order to, for example: transform data in a type-safe way using Scala access Model Lifecycle data generate features based on online data snapshots Once they get the data, they'd like to analyze and visualize it using the Python tools they are familiar with, such as pandas and matplotlib . A more complex example of a more typical usage can be found in the examples/ folder in Plotting Scala data with Matplotlib.ipynb which is reproduced below. We'll go over this example in detail.","title":"Use Case: Plotting Scala data with Matplotlib"},{"location":"docs/mixing-programming-languages/#a-direct-approach-using-primitives","text":"This notebook takes a direct approach to polyglot development. By crossing language boundaries using primitive data structures, you don't need to worry about the details of language-specific data structures or implementations. Let's go over this notebook, which consists of two cells. The first, a Scala cell, prepares some data, while the second, a Python cell, plots it. Scala cell val colors = Array ( \"red\" , \"green\" , \"blue\" ) val n = 750 val flattenedLength = colors . length * n * 2 // 2 for x and y val data = ( 0 until flattenedLength ). map ( _ => Math . random ()). toArray // converted to Array for Python interop This cell generates an Array [ Double ] that is a flattened representation of data in three dimensions - color , x , and y . This data is then fed into the Python cell to be plotted: Python cell import matplotlib.pyplot as plt from numpy.random import rand fig , ax = plt . subplots () for color in colors : # since data is just a 1-D array we need to split it up to fit the matplotlib example x = data [: n ] data = data [ n :] y = data [: n ] data = data [ n :] scale = 200.0 * rand ( n ) ax . scatter ( x , y , c = color , s = scale , label = color , alpha = 0.3 , edgecolors = 'none' ) ax . legend () ax . grid ( True ) plt . show () This cell steps through the data array and, for each color , unflattens the x and y data for plotting (note that both data and color are Scala variables accessed directly from Python).","title":"A direct approach using primitives"},{"location":"docs/mixing-programming-languages/#can-we-do-better","text":"This is pretty straightforward, but you might have noticed that the interchange values between the two languages are Array s, rather than the more idiomatic (for Scala) Seq s. You might also notice that it was pretty unnatural to flatten data like we did. The reason for this is that it's easier to interchange between Scala and Python using primitives and basic structures like Arrays. You might not realize it, but when you work with Scala there's all sorts of stuff going on behind the scenes, such as implicits, or encoded Java method names (like $colon$colon() ). Python doesn't know about this, so when we interact with a Scala object from Python we see it in all its gory details: However, with a little Scala knowledge we can rewrite the plotting code to be more idiomatic, at the expense of having to do (a bit) more work in Python to massage the data.","title":"Can we do better?"},{"location":"docs/mixing-programming-languages/#a-more-idiomatic-implementation","text":"First, we'll use some more idiomatic code to generate our point data: case class Point ( x : Double , y : Double , color : String ) val colors = Seq ( \"red\" , \"green\" , \"blue\" ) val n = 750 val idiomaticData = for { color <- colors n <- ( 0 to n ) } yield Point ( Math . random (), Math . random (), color ) Wow, a case class AND a for expression? This is surely extremely idiomatic Scala code. Not an Array in sight! Let's inspect idiomaticData for a moment. Inspecting and Visualizing Data This image showcases using the Quick Inspector and Viz cells to easily inspect values within a notebook. Now that we've taken a look at idiomaticData and seen that it's a Seq [ Point ] , we can delete the Viz cell and start working with it using Python. Since we're no longer working with primitives, we need to do a little data preparation. We'll build a list , iterate over idiomaticData , and extract values from Point . We want to end up with a simple 2D-Array we can use with matplotlib . data = [] for idx in range ( 0 , idiomaticData . length ()): point = idiomaticData . apply ( idx ) data . append ([ point . x (), point . y (), point . color ()]) There are two things of note here. First, we need to manually iterate through the collection, generating an index which we can pass into the apply ( idx : Int ): A method of the Seq to select elements from it. Second, we'll access the case class members using the member accessor methods as usual, but note that with Python we need to specify () , as in point . x () , since of course in Python parentheses are always required, even for nullary functions (ones that have no arguments). At this point, the data variable is a nice list of list s, and we can easily turn it into a Pandas DataFrame: import pandas as pd df = pd . DataFrame ( data = data , columns = [ 'x' , 'y' , 'color' ]) Note that we have to manually specify the column names here. A more advanced example might extract the fields from Point and pass them into Python, but we'll pass on that for now. Now that our data is a Pandas DataFrame we can manipulate it as usual. For example, we can add a scale column to it: import numpy as np df [ 'scale' ] = np . random . uniform ( 1 , 200 , df . shape [ 0 ]) Finally, we can plot our DataFrame in the familiar way. import matplotlib.pyplot as plt fig , ax = plt . subplots () groups = df . groupby ( \"color\" ) for name , group in groups : ax . scatter ( group . x , group . y , c = group . color , s = group . scale , label = name , alpha = 0.3 , edgecolors = 'none' ) ax . legend ( loc = \"upper right\" ) ax . grid ( True ) plt . show () That's it! This notebook can be found in the examples/ folder as well, in Plotting Scala data with Matplotlib (Idiomatic).ipynb . You can see a screenshot below. Next, read about using Spark with Polynote .","title":"A more idiomatic implementation"},{"location":"docs/notebook-configuration/","text":"The Notebook Configuration section allows you to set metadata for this notebook's execution environment. The environment can be broken up into three general categories, as shown in the following diagram: Dependencies : the JVM and Python dependencies needed by your code Spark Properties : Spark-specific configuration Kernel Configuration : other runtime configuration for the Kernel Dependencies \u00b6 This section provides options for configuring dependencies that should be available when the notebook is executed. JVM dependencies \u00b6 JVM dependencies can be specified in the familiar Group, Artifact, Version (or GAV) notation , such as org.http4s:http4s-core:1.0.0-M16 . Polynote will resolve and download this dependency, as well as its transitive dependencies, using Coursier . Use the Exclusions section to exclude any pesky transitive dependencies that are causing you problems. Use the Resolvers section to set up any custom resolvers (e.g., your company's internal resolver). Polynote supports both Maven and Ivy resolvers (the type of resolver can be selected in the dropdown). Additionally, Polynote supports specifying a URL directly to a jar file - such as file:///home/jars/myCoolLibrary.jar . Supported schemas include http and s3 (if Spark is enabled). Warning Note that if you specify a jar directly, Polynote will not resolve any transitive dependencies for this jar. In general, we recommend using GAV coordinates if you can. Python dependencies \u00b6 Similarly, Polynote allows you to specify Python dependencies using anything supported by pip This means that you can specify pip dependencies by simply naming them, (e.g., requests ), using a version ( requests==2.25.1 ), and even a requirement specifier ( requests>=2.25 ). You can also pass in a file URL, as long as it's supported by pip. You can also specify additional pip resolvers (e.g., your company's internal resolver) in the Resolvers section (select pip in the dropdown). Polynote just passes the resolver into pip (using --extra-index-url ), so be sure your repository URL works with that. Polynote creates a virtual environment for your notebook when you specify any pip dependencies. See the python documentation for more details. Dependency Caching \u00b6 By default, Polynote caches JVM dependencies that are specified with URLs, as well as the virtual environment created for your notebook . You can choose to manually bust the cache by unfolding the Advanced Options pane for your dependency by clicking on the ... button next to it. Changing the cache option affects different types of dependencies differently. JVM Dependencies URL-based dependencies are affected by this setting. If using the cache, Polynote uses the cached file (if present) instead of downloading it again. Conversely, if the cache is disabled for this dependency then Polynote will download the jar anew each time. GAV notation dependencies are unaffected by this change (Coursier caches these dependencies itself and we don't expose any way to change that for now) Python Dependencies Python dependencies are affected by this setting. Since they share a virtual environment for this notebook, bypassing the cache for any Python dependency will bust the cache for all Python dependencies , since this is implmemented as a simple deletion and recreation of the virtual environment. Feedback requested If these restrictions are inconvenient for you, please let us know and we can look into improving this feature. Spark \u00b6 There are two complementary ways to specify Spark properties. Spark Templates are sets of related configuration that can be defined in the Server Configuration Spark Properties are key-value pairs that Polynote will insert into the Spark configuration. For more details on using Spark with Polynote, check out the Spark documentation Kernel \u00b6 The Kernel configuration contains some miscellaneous configuration that affect the runtime environment of the Kernel. First, the Scala version can be set (independently of the version running on the server). Currently, only 2.11 and 2.12 are supported (since those are the versions supported by Spark). Warning The Scala version you select must match that of your Spark installation. If you're unsure what that is, just leave it as Default and Polynote will take care of it for you! In the second section, you can also add Environment Variables that will be made available to the Kernel process. Finally, in the last section you can add any additional JVM Arguments that Polynote will set when it launches the Kernel process.","title":"Configuration"},{"location":"docs/notebook-configuration/#dependencies","text":"This section provides options for configuring dependencies that should be available when the notebook is executed.","title":"Dependencies"},{"location":"docs/notebook-configuration/#jvm-dependencies","text":"JVM dependencies can be specified in the familiar Group, Artifact, Version (or GAV) notation , such as org.http4s:http4s-core:1.0.0-M16 . Polynote will resolve and download this dependency, as well as its transitive dependencies, using Coursier . Use the Exclusions section to exclude any pesky transitive dependencies that are causing you problems. Use the Resolvers section to set up any custom resolvers (e.g., your company's internal resolver). Polynote supports both Maven and Ivy resolvers (the type of resolver can be selected in the dropdown). Additionally, Polynote supports specifying a URL directly to a jar file - such as file:///home/jars/myCoolLibrary.jar . Supported schemas include http and s3 (if Spark is enabled). Warning Note that if you specify a jar directly, Polynote will not resolve any transitive dependencies for this jar. In general, we recommend using GAV coordinates if you can.","title":"JVM dependencies"},{"location":"docs/notebook-configuration/#python-dependencies","text":"Similarly, Polynote allows you to specify Python dependencies using anything supported by pip This means that you can specify pip dependencies by simply naming them, (e.g., requests ), using a version ( requests==2.25.1 ), and even a requirement specifier ( requests>=2.25 ). You can also pass in a file URL, as long as it's supported by pip. You can also specify additional pip resolvers (e.g., your company's internal resolver) in the Resolvers section (select pip in the dropdown). Polynote just passes the resolver into pip (using --extra-index-url ), so be sure your repository URL works with that. Polynote creates a virtual environment for your notebook when you specify any pip dependencies. See the python documentation for more details.","title":"Python dependencies"},{"location":"docs/notebook-configuration/#dependency-caching","text":"By default, Polynote caches JVM dependencies that are specified with URLs, as well as the virtual environment created for your notebook . You can choose to manually bust the cache by unfolding the Advanced Options pane for your dependency by clicking on the ... button next to it. Changing the cache option affects different types of dependencies differently. JVM Dependencies URL-based dependencies are affected by this setting. If using the cache, Polynote uses the cached file (if present) instead of downloading it again. Conversely, if the cache is disabled for this dependency then Polynote will download the jar anew each time. GAV notation dependencies are unaffected by this change (Coursier caches these dependencies itself and we don't expose any way to change that for now) Python Dependencies Python dependencies are affected by this setting. Since they share a virtual environment for this notebook, bypassing the cache for any Python dependency will bust the cache for all Python dependencies , since this is implmemented as a simple deletion and recreation of the virtual environment. Feedback requested If these restrictions are inconvenient for you, please let us know and we can look into improving this feature.","title":"Dependency Caching"},{"location":"docs/notebook-configuration/#spark","text":"There are two complementary ways to specify Spark properties. Spark Templates are sets of related configuration that can be defined in the Server Configuration Spark Properties are key-value pairs that Polynote will insert into the Spark configuration. For more details on using Spark with Polynote, check out the Spark documentation","title":"Spark"},{"location":"docs/notebook-configuration/#kernel","text":"The Kernel configuration contains some miscellaneous configuration that affect the runtime environment of the Kernel. First, the Scala version can be set (independently of the version running on the server). Currently, only 2.11 and 2.12 are supported (since those are the versions supported by Spark). Warning The Scala version you select must match that of your Spark installation. If you're unsure what that is, just leave it as Default and Polynote will take care of it for you! In the second section, you can also add Environment Variables that will be made available to the Kernel process. Finally, in the last section you can add any additional JVM Arguments that Polynote will set when it launches the Kernel process.","title":"Kernel"},{"location":"docs/notebook/","text":"The Notebook Pane displays the contents of the notebooks themselves. A notebook consists of its Configuration and a collection of Text , Code , and Viz cells.","title":"Notebook"},{"location":"docs/notebooks-list/","text":"The Notebooks List displays a listing of all the notebooks in your current workspace. Notebooks are displayed in a directory structure. Clicking on a notebook opens it, and clicking on a directory expands or collapses it. Tip The current workspace can be set in the Storage Configuration . Creating a new notebook \u00b6 You can create a new notebook by clicking on the green plus sign in the corner. This will bring up the Create Notebook Dialog, where you can enter the notebook name. If a notebook with that name already exists, a number will be appended at the end of the filename. Tip Any slashes in the notebook name will place your new notebook in a directory (creating them if they don't already exist). Addiitonally, Polynote will add an extension if you don't specify one. For example, typing in foo/bar/My Notebook will create a My Notebook.ipynb file and put it into a directory named bar , within a directory named foo . Importing a notebook \u00b6 Importing a notebook into Polynote is as simple as dragging and dropping the file onto the Notebooks List! Supported import formats Polynote supports importing your existing Jupyter .ipynb files and Zeppelin .json files. Zeppelin files will be automatically converted into .ipynb files upon import. Note that Polynote doesn't do any translation of the notebook contents, so any platform-specific features, such as Jupyter \"magics\" (like Toree's %AddJar ) or Zeppelin's z.load syntax will need to be manually converted. Rename, Copy, Delete \u00b6 You can Rename, Copy, and Delete notebooks using the Context Menu, which you can bring up by right-clicking on a notebook. Here's a demonstration of Renaming a notebook using the Context Menu. The Copy and Delete functions work rather similarly.","title":"Notebooks List"},{"location":"docs/notebooks-list/#creating-a-new-notebook","text":"You can create a new notebook by clicking on the green plus sign in the corner. This will bring up the Create Notebook Dialog, where you can enter the notebook name. If a notebook with that name already exists, a number will be appended at the end of the filename. Tip Any slashes in the notebook name will place your new notebook in a directory (creating them if they don't already exist). Addiitonally, Polynote will add an extension if you don't specify one. For example, typing in foo/bar/My Notebook will create a My Notebook.ipynb file and put it into a directory named bar , within a directory named foo .","title":"Creating a new notebook"},{"location":"docs/notebooks-list/#importing-a-notebook","text":"Importing a notebook into Polynote is as simple as dragging and dropping the file onto the Notebooks List! Supported import formats Polynote supports importing your existing Jupyter .ipynb files and Zeppelin .json files. Zeppelin files will be automatically converted into .ipynb files upon import. Note that Polynote doesn't do any translation of the notebook contents, so any platform-specific features, such as Jupyter \"magics\" (like Toree's %AddJar ) or Zeppelin's z.load syntax will need to be manually converted.","title":"Importing a notebook"},{"location":"docs/notebooks-list/#rename-copy-delete","text":"You can Rename, Copy, and Delete notebooks using the Context Menu, which you can bring up by right-clicking on a notebook. Here's a demonstration of Renaming a notebook using the Context Menu. The Copy and Delete functions work rather similarly.","title":"Rename, Copy, Delete"},{"location":"docs/python/","text":"For now, Python is the major non-JVM-based language you'll be using with Polynote. Polynote uses Jep to execute Python code within the JVM. Jep does most of the heavy-lifting when it comes to Python interop. Most Python code should work out of the box on Polynote, without needing anything special. Please let us know if you run into any problems with Python code that works well in Jupyter or the Python REPL. Python dependencies \u00b6 When you specify a Python dependency in the configuration , Polynote creates a virtual environment scoped to your notebook. This virtual environment is reused on subsequent runs of the notebook, unless your dependencies change or you explicitly bust the cache . Additionally, the virtual environments are isolated from each other but not from the system, since Polynote specifies the --system-site-packages flag when creating the environment. Experimental: PySpark And Dependencies Polynote attempts to add the dependencies you specify to Spark by downloading their zip files and adding them to the Spark context if it exists. This means that your Python dependencies should be shipped to your executors (and available) to your code that runs there! Sharing between Python and Scala \u00b6 Our goals right now are to support a few, key use-cases with a focus on sharing from Scala to Python, such as plotting data generated in Scala with matplotlib , or using Scala-generated data with tensorflow and scikit-learn . We've found that the interop between Python and Scala can be very powerful even if it is limited to these simple cases. Tip If you're going to be moving back and forth between Python and Scala a lot, we highly recommend reading how Jep works . Here are a few important points to keep in mind when sharing between Python and Scala: Jep handles the conversion from Scala -> Python. It converts primitives and strings into brand-new Python primitives and strings. An object of any other type is wrapped as a PyJObject , which is an interface allowing Python to directly access that objects attributes. Note that in this case, nothing is copied - PyJObject holds a reference to the underlying JVM object. Note that Jep is based on Java, not Scala. This means that when it wraps a Scala object as a PyJObject , you won't get Scala sugar - things like multiple parameter lists, implicits, etc. - when you work with it in Python. This can limit your ability to use a lot of super-scala-stuff with Python. Jep handles conversion from Python -> Scala and Polynote adds a little bit of sugar on top. Similar to the other way round, Jep automatically converts primitives and strings into brand-new JVM primitives and strings. Additionally, Jep supports some other conversions such as Python dict to java.util.HashMap Polynote will retrieve an object of any other type as a PyObject . Similar to PyJObject , a PyObject wraps a pointer to a Python object. Polynote has some support for handling certain types of Python objects, typically for visualization purposes. Note that these implementation details may change and while we'll work hard to update this information we can't guarantee that it won't get out-of-date. Of course, feel free to drop us a line if you think that's the case!","title":"Using Polynote with Python"},{"location":"docs/python/#python-dependencies","text":"When you specify a Python dependency in the configuration , Polynote creates a virtual environment scoped to your notebook. This virtual environment is reused on subsequent runs of the notebook, unless your dependencies change or you explicitly bust the cache . Additionally, the virtual environments are isolated from each other but not from the system, since Polynote specifies the --system-site-packages flag when creating the environment. Experimental: PySpark And Dependencies Polynote attempts to add the dependencies you specify to Spark by downloading their zip files and adding them to the Spark context if it exists. This means that your Python dependencies should be shipped to your executors (and available) to your code that runs there!","title":"Python dependencies"},{"location":"docs/python/#sharing-between-python-and-scala","text":"Our goals right now are to support a few, key use-cases with a focus on sharing from Scala to Python, such as plotting data generated in Scala with matplotlib , or using Scala-generated data with tensorflow and scikit-learn . We've found that the interop between Python and Scala can be very powerful even if it is limited to these simple cases. Tip If you're going to be moving back and forth between Python and Scala a lot, we highly recommend reading how Jep works . Here are a few important points to keep in mind when sharing between Python and Scala: Jep handles the conversion from Scala -> Python. It converts primitives and strings into brand-new Python primitives and strings. An object of any other type is wrapped as a PyJObject , which is an interface allowing Python to directly access that objects attributes. Note that in this case, nothing is copied - PyJObject holds a reference to the underlying JVM object. Note that Jep is based on Java, not Scala. This means that when it wraps a Scala object as a PyJObject , you won't get Scala sugar - things like multiple parameter lists, implicits, etc. - when you work with it in Python. This can limit your ability to use a lot of super-scala-stuff with Python. Jep handles conversion from Python -> Scala and Polynote adds a little bit of sugar on top. Similar to the other way round, Jep automatically converts primitives and strings into brand-new JVM primitives and strings. Additionally, Jep supports some other conversions such as Python dict to java.util.HashMap Polynote will retrieve an object of any other type as a PyObject . Similar to PyJObject , a PyObject wraps a pointer to a Python object. Polynote has some support for handling certain types of Python objects, typically for visualization purposes. Note that these implementation details may change and while we'll work hard to update this information we can't guarantee that it won't get out-of-date. Of course, feel free to drop us a line if you think that's the case!","title":"Sharing between Python and Scala"},{"location":"docs/server-configuration/","text":"To change any of the default configuration, you'll need to copy the included config-template.yml file to config.yml , and uncomment the sections you'd like to change. Check out the template itself for more information. Storage \u00b6","title":"Server Configuration"},{"location":"docs/server-configuration/#storage","text":"","title":"Storage"},{"location":"docs/spark/","text":"Using Spark with Polynote \u00b6 Polynote has deep integration with Apache Spark , and supports running both Scala and Python code with Spark out of the box. In order to use Spark, you must first have it installed . Then, open the configuration for the notebook you'd like to use with Spark, and scroll down to the Spark configuration section. As long as you set anything there - any Spark property, any Spark template - and Polynote will launch your notebook with Spark enabled.","title":"Using Polynote with Spark"},{"location":"docs/spark/#using-spark-with-polynote","text":"Polynote has deep integration with Apache Spark , and supports running both Scala and Python code with Spark out of the box. In order to use Spark, you must first have it installed . Then, open the configuration for the notebook you'd like to use with Spark, and scroll down to the Spark configuration section. As long as you set anything there - any Spark property, any Spark template - and Polynote will launch your notebook with Spark enabled.","title":"Using Spark with Polynote"},{"location":"docs/text-cells/","text":"Text Cells provide a Rich Text Editing experience, allowing you to edit and format text as you type it, like editing a document. The Text Toolbar contains standard Rich Text Editing elements: Text style (Heading, Paragraph, etc.) Emphasis (bold, italic, underline, strikethrough) List (unordered, ordered) Indentation It also contains a few non-Standard options. Code and Links \u00b6 The code button tags the currently-selected text as code , formatting it as monospaced. The link button tags the currently-selected text as a link. Clinking on a link will reveal the URL in a tooltip, allowing you to navigate to the website. LaTeX Editor \u00b6 You can also input LaTeX into your text cells, using the button that looks like a Sigma.","title":"Text Cells"},{"location":"docs/text-cells/#code-and-links","text":"The code button tags the currently-selected text as code , formatting it as monospaced. The link button tags the currently-selected text as a link. Clinking on a link will reveal the URL in a tooltip, allowing you to navigate to the website.","title":"Code and Links"},{"location":"docs/text-cells/#latex-editor","text":"You can also input LaTeX into your text cells, using the button that looks like a Sigma.","title":"LaTeX Editor"},{"location":"docs/toolbar/","text":"The toolbar is one of the primary ways you'll be interacting with Polynote. It is divided into sections, which we will go over now. The toolbar is divided into three sections: Notebook , Cell and About . Notebook section \u00b6 This section contains buttons that interact with the currently active notebook. The three relevant buttons are: The Run All button which queues up all cells of the current notebook to run in order. The Download button which downloads the current notebook as an ipynb file. The Clear Output button which clears the output of all notebook cells. The other two buttons are placeholders for future functionality that are currently not in use. Cell section \u00b6 This section contains elements for interacting with the currently active cell. This section has two subsections. On the left is the Cell section, which holds elements for interacting with the current cell regardless of its type. On the right is the a cell detail section, which changes depending on whether the currently active cell is a Code or Text cell. We'll start with the invariant Cell section first. The Cell Type dropdown is used to change the type of the cell. This is equivalent to the dropdown found on Code cells but it can also convert a cell from Code to Text and vice-versa. The Insert Cell Above and Below buttons, which insert a new cell above or below the currently selected cell. The Delete Cell button which deletes the currently selected cell. Code Cells \u00b6 The run cell button runs the currently selected cell. The next button runs all cells above the currently selected cell until (and including) the currently selected cell. The stop button cancels any currently-running execution (not limited to the current cell). See the advanced section to learn more about how stopping works. Text Cells \u00b6 The Text cell subsection contains the typical rich text editor interaction elements, along with a few special ones. For more details, see the Text Cell documentation. About section \u00b6 Finally, the About section at the top-right corner contains buttons to access the About menu .","title":"Toolbar"},{"location":"docs/toolbar/#notebook-section","text":"This section contains buttons that interact with the currently active notebook. The three relevant buttons are: The Run All button which queues up all cells of the current notebook to run in order. The Download button which downloads the current notebook as an ipynb file. The Clear Output button which clears the output of all notebook cells. The other two buttons are placeholders for future functionality that are currently not in use.","title":"Notebook section"},{"location":"docs/toolbar/#cell-section","text":"This section contains elements for interacting with the currently active cell. This section has two subsections. On the left is the Cell section, which holds elements for interacting with the current cell regardless of its type. On the right is the a cell detail section, which changes depending on whether the currently active cell is a Code or Text cell. We'll start with the invariant Cell section first. The Cell Type dropdown is used to change the type of the cell. This is equivalent to the dropdown found on Code cells but it can also convert a cell from Code to Text and vice-versa. The Insert Cell Above and Below buttons, which insert a new cell above or below the currently selected cell. The Delete Cell button which deletes the currently selected cell.","title":"Cell section"},{"location":"docs/toolbar/#code-cells","text":"The run cell button runs the currently selected cell. The next button runs all cells above the currently selected cell until (and including) the currently selected cell. The stop button cancels any currently-running execution (not limited to the current cell). See the advanced section to learn more about how stopping works.","title":"Code Cells"},{"location":"docs/toolbar/#text-cells","text":"The Text cell subsection contains the typical rich text editor interaction elements, along with a few special ones. For more details, see the Text Cell documentation.","title":"Text Cells"},{"location":"docs/toolbar/#about-section","text":"Finally, the About section at the top-right corner contains buttons to access the About menu .","title":"About section"},{"location":"docs/tour/","text":"Welcome to the tour of Polynote's UI! Polynote takes its inspiration from IDE-like tools, bringing a rich UI into the notebook experience. The Polynote UI \u00b6 Here, we'll go over the various parts of the UI briefly, and then drill down on each later in the tour. This screenshot divides the UI into four sections: The Toolbar at the top, which collects buttons for interaction with the notebook The Notebooks List pane on the left, a file-like browser showing the notebooks in Polynote's workspace The Kernel Pane on the right, which shows the current state of the notebook. The Notebook section itself in the middle, which displays the actual notebook. The above sections provide details about the specific functionality of each part of the UI. Panes in Polynote \u00b6 Before you go learn more about the specifics, let's just talk about how the two panes work. Panes can be collapsed \u00b6 If you'd like more horizontal space to see the Notebook section, you can collapse one or both of the panes. Simply click on any empty space on the header, and the pane will collapse to the side. Click the title of the header (for example, Kernel if you have collapsed the Kernel Pane ) in order to expand the pane again. Panes can be resized \u00b6 If you want more room for the Notebook but don't want to hide a pane entirely, you can resize a pane by dragging it. Tip Polynote remembers your pane collapse and size preferences in your browser's local storage. As long as you're using Polynote with the same browser, your customizations should be persisted! Next up, learn about the Toolbar .","title":"Tour"},{"location":"docs/tour/#the-polynote-ui","text":"Here, we'll go over the various parts of the UI briefly, and then drill down on each later in the tour. This screenshot divides the UI into four sections: The Toolbar at the top, which collects buttons for interaction with the notebook The Notebooks List pane on the left, a file-like browser showing the notebooks in Polynote's workspace The Kernel Pane on the right, which shows the current state of the notebook. The Notebook section itself in the middle, which displays the actual notebook. The above sections provide details about the specific functionality of each part of the UI.","title":"The Polynote UI"},{"location":"docs/tour/#panes-in-polynote","text":"Before you go learn more about the specifics, let's just talk about how the two panes work.","title":"Panes in Polynote"},{"location":"docs/tour/#panes-can-be-collapsed","text":"If you'd like more horizontal space to see the Notebook section, you can collapse one or both of the panes. Simply click on any empty space on the header, and the pane will collapse to the side. Click the title of the header (for example, Kernel if you have collapsed the Kernel Pane ) in order to expand the pane again.","title":"Panes can be collapsed"},{"location":"docs/tour/#panes-can-be-resized","text":"If you want more room for the Notebook but don't want to hide a pane entirely, you can resize a pane by dragging it. Tip Polynote remembers your pane collapse and size preferences in your browser's local storage. As long as you're using Polynote with the same browser, your customizations should be persisted! Next up, learn about the Toolbar .","title":"Panes can be resized"},{"location":"docs/visualization-and-viz-cells/","text":"Polynote supports a number of different ways to visualize data. Data Reprs \u00b6 All symbols in a Polynote notebook have one or more Reprs , short for \"Representations\", that Polynote generates and then sends to the frontend. They range from simple (such as the symbol's toString() value), to the complex (such as a streaming view into a Spark DataFrame ). Reprs form the building blocks for all of Polynote's native data visualization. They can be viewed in a number of different ways. For example, as the result of a Code Cell , or in a Viz cell . Let's take a look at a simple example: the Reprs generated for a String . We'll show them in both a Code Cell result as well as a Viz Cell. As the result of a Code Cell, the String is being stored in the Out symbol. Polynote generates two Reprs for a String . First, all symbols get a StringRepr , which just corresponds to its toString() output. Additionally, most symbols have some sort of representation of the symbol's type and value, such as a DataRepr in this case, which carries the symbol's type as well as a serialized representation of symbol's entire value. In this case, Out 's DataRepr is seen both in the output of Cell 3, and in the \"Data\" tab of the Viz cell. In this case, since Out is a simple String , its DataRepr displays its value in its entirety. Clicking on the \"Plain\" tab of the Viz cell would display Out 's StringRepr , which is, of course, simply \"foo\" . Repr display priority When there are multiple Reprs available, Polynote tries to choose the richest available Repr as the default one to display. In this case, the DataRepr is clearly richer than the StringRepr , which is why it's shown in the Code cell output and displayed by default in the Viz cell. Visualization Cell Types \u00b6 While Code Cells do show some handy visualization of results , for plotting or as permanent fixtures of a notebook, it makes sense to break out the visualization of a specific value into its own cell. Polynote provides native Vega support for plotting data. A Vega spec can be rendered using a Code Cell, by changing its language to \"Vega spec\". Additionally, Viz Cells provide a Plot Editor for supported data types. We'll start by discussing Polynote's Vega support. Vega Cells \u00b6 Vega Cells are merely Code Cells with Vega spec set as the language. As an example, here's the \"Simple Bar Chart\" example from the Vega-Lite Docs in Polynote. Note that the data in this chart is stored under values in the data field of the spec itself. That's not terribly useful: most of the time, you'll want to reference data defined in variables in your notebook. Luckily, Polynote supports that! Let's rewrite the Vega example but this time we'll have it reference data defined in Scala. First, we'll grab the data from the example and turn it into a Scala cell: case class AB ( a : String , b : Int ) val dataValues = Seq ( AB ( \"A\" , 28 ), AB ( \"B\" , 55 ), AB ( \"C\" , 43 ), AB ( \"D\" , 91 ), AB ( \"E\" , 81 ), AB ( \"F\" , 53 ), AB ( \"G\" , 19 ), AB ( \"H\" , 87 ), AB ( \"I\" , 52 ) ) Now, we can reference dataValues in our code. { \"$schema\" : \"https://vega.github.io/schema/vega-lite/v4.json\" , \"title\" : \"dataValues\" , \"data\" : { \"name\" : \"dataValues\" , \"values\" : da ta Values.aggrega te ( [ \"a\" ], [{ \"b\" : \"mean\" }] ) }, \"mark\" : { \"type\" : \"bar\" , \"tooltip\" : { \"content\" : \"data\" } }, \"encoding\" : { \"x\" : { \"field\" : \"a\" , \"type\" : \"nominal\" , \"axis\" : {}}, \"y\" : { \"field\" : \"mean(b)\" , \"type\" : \"quantitative\" , \"axis\" : {}} } } In order to transform the Scala code into something that Vega can handle, we call aggregate on the collection which collects the values into a format that Vega can understand. TODO: why \"mean\"? Remembering the aggregation syntax can be tricky, which is why we recommend using the Plot Editor in a Viz Cell . Viz Cells \u00b6 Viz cells are a type of cell specifically geared towards, well, visualization. A Viz cell inspects the Reprs of a single symbol defined in the notebook, and provides ways to visualize it. You can create a new Viz cell by clicking on a Code Cell inspection button (which will create a new Viz cell inspecting the Out result of the cell), or through the Quick Inspector (which will create a new Viz cell inspecting the current symbol). Like other cells, a Viz cell can only inspect symbols that are in its scope, that is, defined in a cell above it. We already saw a simple Viz cell above , so let's take a look at a more interesting example: the dataValues shown earlier . As a reminder, dataValues is a collection of type Seq [ AB ] , where AB is case class AB ( a : String , b : Int ) . This time, we'll start with the \"Plain\" tab of the Viz cell, which shows the StringRepr as mentioned above (you might recognize this output as the result of calling toString() on a Scala List ). Notice that this Viz Cell has no \"Data\" tab. Instead, there are three tabs we haven't seen before: \"Plot\", \"Schema\", and \"Browse\". These new tabs are actually all generated from the same Repr ! Since dataValues is a collection, Polynote generates a StreamingDataRepr for it, which is a special type of DataRepr specifically meant for collections. More about StreamingDataRepr Unlike DataRepr , StreamingDataRepr is a lazy representation of the data. This means that when a StreamingDataRepr is sent to the frontend, the data stored in the value remains in the kernel and can be streamed to the frontend in batches. This is particularly useful when dealing with potentially huge datasets, like Spark DataFrame s, which are streams themselves. Let's take a look at the three new tabs, which show different aspects of the StreamingDataRepr of dataValues . Schema \u00b6 The Schema view shows the types of the entries in the collection. In this case, the fields of AB are a a : String and b : Int , shown below in a struct-like display. Nested schemas can also be expanded, like nested data in a Code Cell's output . Browse \u00b6 The Browse view provides a tabular view of dataValues . As the data is streamed to the browser, you'll need to page through it to see any values, as shown below. The example data all fits in the first page, but larger data can be paged back and forth as needed. Note that paging through the data may potentially start non-trivial computations in some cases (e.g., with a Spark DataFrame ) Plot \u00b6 The Plot view is the most complex part of a Viz Cell. It contains a Plot Editor which generates a Vega plot in a more straightforward manner, allowing customization of the plot type, selection of Dimensions and Measures to plot, and more without the need to edit Vega code directly. The example below shows the Plot Editor being used to generate the example graph shown in the Vega Cell documentation above . To extract the Vega spec generated by the editor, click on the to generate a Vega Cell that contains the generated spec. Other ways to visualize \u00b6 If the Reprs that Polynote automatically generates aren't enough, there are plenty of other ways to hook into Polynote's display capabilities. Defining your own Reprs \u00b6 If you'd like to add display capabilities to types in your code, you can implement your own Reprs by extending the ReprsOf trait. This allows you to register Reprs for your types. The easiest way to create a new Repr is to use a MIMERepr , which takes a MIME type and content string. For example, you to display some HTML you could return MIMERepr ( \"text/html\" , \"<h1>Heading</h1>\" ) , or to show an image you could return MIMERepr ( \"image/png\" , \"<a base64 encoding of a PNG>\" ) . Here's an example adding a simple HTML MIMERepr for the results of type MyThing . DOESN'T WORK! import polynote . runtime . _ case class MyThing ( a : String ) object MyThing { implicit object MyThingRepr extends ReprsOf [ MyThing3 ]{ override def apply ( value : MyThing ): Array [ ValueRepr ] = Array ( MIMERepr ( \"text/html\" , s\"<strong> ${ value . a } </strong>\" )) } } MyThing ( \"hi\" ) Using kernel.display \u00b6 Let's say you just want to display some output, but you don't want to go through the trouble of defining a special Repr . You can use the kernel.display package (available in polynote.runtime ) to hook into Polynote's display mechanism. To display an HTML string, use kernel . display . html ( content : String ) , which takes in a String and outputs it as HTML. You can also display other MIME types using kernel . display . content ( mimeType : String , content : String ) , where content is a String representation of the content (e.g., base64 encoded for an image). In fact, kernel.display.html is actually a shortcut for kernel . display . content ( \"text/html\" , _ ) . Visualization with Python \u00b6 The Python ecosystem has a rich history of notebook usage with Jupyter/IPython, and many Python libraries define rich display representations for use in a notebook environment. Polynote supports these _repr_*_() methods, too! Polynote simply translates these methods into their corresponding MIMERepr . Polynote supports all of the _repr_*_() standard methods, including _repr_mimebundle_() . This means that the IPython.display API also works in Polynote. Additionally, Polynote understands pandas . DataFrame s and generates StreamingDataRepr s for them, just like it does for Spark. Finally, as shown in the tour , Polynote supports matplotlib , too!","title":"Visualization and Viz Cells"},{"location":"docs/visualization-and-viz-cells/#data-reprs","text":"All symbols in a Polynote notebook have one or more Reprs , short for \"Representations\", that Polynote generates and then sends to the frontend. They range from simple (such as the symbol's toString() value), to the complex (such as a streaming view into a Spark DataFrame ). Reprs form the building blocks for all of Polynote's native data visualization. They can be viewed in a number of different ways. For example, as the result of a Code Cell , or in a Viz cell . Let's take a look at a simple example: the Reprs generated for a String . We'll show them in both a Code Cell result as well as a Viz Cell. As the result of a Code Cell, the String is being stored in the Out symbol. Polynote generates two Reprs for a String . First, all symbols get a StringRepr , which just corresponds to its toString() output. Additionally, most symbols have some sort of representation of the symbol's type and value, such as a DataRepr in this case, which carries the symbol's type as well as a serialized representation of symbol's entire value. In this case, Out 's DataRepr is seen both in the output of Cell 3, and in the \"Data\" tab of the Viz cell. In this case, since Out is a simple String , its DataRepr displays its value in its entirety. Clicking on the \"Plain\" tab of the Viz cell would display Out 's StringRepr , which is, of course, simply \"foo\" . Repr display priority When there are multiple Reprs available, Polynote tries to choose the richest available Repr as the default one to display. In this case, the DataRepr is clearly richer than the StringRepr , which is why it's shown in the Code cell output and displayed by default in the Viz cell.","title":"Data Reprs"},{"location":"docs/visualization-and-viz-cells/#visualization-cell-types","text":"While Code Cells do show some handy visualization of results , for plotting or as permanent fixtures of a notebook, it makes sense to break out the visualization of a specific value into its own cell. Polynote provides native Vega support for plotting data. A Vega spec can be rendered using a Code Cell, by changing its language to \"Vega spec\". Additionally, Viz Cells provide a Plot Editor for supported data types. We'll start by discussing Polynote's Vega support.","title":"Visualization Cell Types"},{"location":"docs/visualization-and-viz-cells/#vega-cells","text":"Vega Cells are merely Code Cells with Vega spec set as the language. As an example, here's the \"Simple Bar Chart\" example from the Vega-Lite Docs in Polynote. Note that the data in this chart is stored under values in the data field of the spec itself. That's not terribly useful: most of the time, you'll want to reference data defined in variables in your notebook. Luckily, Polynote supports that! Let's rewrite the Vega example but this time we'll have it reference data defined in Scala. First, we'll grab the data from the example and turn it into a Scala cell: case class AB ( a : String , b : Int ) val dataValues = Seq ( AB ( \"A\" , 28 ), AB ( \"B\" , 55 ), AB ( \"C\" , 43 ), AB ( \"D\" , 91 ), AB ( \"E\" , 81 ), AB ( \"F\" , 53 ), AB ( \"G\" , 19 ), AB ( \"H\" , 87 ), AB ( \"I\" , 52 ) ) Now, we can reference dataValues in our code. { \"$schema\" : \"https://vega.github.io/schema/vega-lite/v4.json\" , \"title\" : \"dataValues\" , \"data\" : { \"name\" : \"dataValues\" , \"values\" : da ta Values.aggrega te ( [ \"a\" ], [{ \"b\" : \"mean\" }] ) }, \"mark\" : { \"type\" : \"bar\" , \"tooltip\" : { \"content\" : \"data\" } }, \"encoding\" : { \"x\" : { \"field\" : \"a\" , \"type\" : \"nominal\" , \"axis\" : {}}, \"y\" : { \"field\" : \"mean(b)\" , \"type\" : \"quantitative\" , \"axis\" : {}} } } In order to transform the Scala code into something that Vega can handle, we call aggregate on the collection which collects the values into a format that Vega can understand. TODO: why \"mean\"? Remembering the aggregation syntax can be tricky, which is why we recommend using the Plot Editor in a Viz Cell .","title":"Vega Cells"},{"location":"docs/visualization-and-viz-cells/#viz-cells","text":"Viz cells are a type of cell specifically geared towards, well, visualization. A Viz cell inspects the Reprs of a single symbol defined in the notebook, and provides ways to visualize it. You can create a new Viz cell by clicking on a Code Cell inspection button (which will create a new Viz cell inspecting the Out result of the cell), or through the Quick Inspector (which will create a new Viz cell inspecting the current symbol). Like other cells, a Viz cell can only inspect symbols that are in its scope, that is, defined in a cell above it. We already saw a simple Viz cell above , so let's take a look at a more interesting example: the dataValues shown earlier . As a reminder, dataValues is a collection of type Seq [ AB ] , where AB is case class AB ( a : String , b : Int ) . This time, we'll start with the \"Plain\" tab of the Viz cell, which shows the StringRepr as mentioned above (you might recognize this output as the result of calling toString() on a Scala List ). Notice that this Viz Cell has no \"Data\" tab. Instead, there are three tabs we haven't seen before: \"Plot\", \"Schema\", and \"Browse\". These new tabs are actually all generated from the same Repr ! Since dataValues is a collection, Polynote generates a StreamingDataRepr for it, which is a special type of DataRepr specifically meant for collections. More about StreamingDataRepr Unlike DataRepr , StreamingDataRepr is a lazy representation of the data. This means that when a StreamingDataRepr is sent to the frontend, the data stored in the value remains in the kernel and can be streamed to the frontend in batches. This is particularly useful when dealing with potentially huge datasets, like Spark DataFrame s, which are streams themselves. Let's take a look at the three new tabs, which show different aspects of the StreamingDataRepr of dataValues .","title":"Viz Cells"},{"location":"docs/visualization-and-viz-cells/#schema","text":"The Schema view shows the types of the entries in the collection. In this case, the fields of AB are a a : String and b : Int , shown below in a struct-like display. Nested schemas can also be expanded, like nested data in a Code Cell's output .","title":"Schema"},{"location":"docs/visualization-and-viz-cells/#browse","text":"The Browse view provides a tabular view of dataValues . As the data is streamed to the browser, you'll need to page through it to see any values, as shown below. The example data all fits in the first page, but larger data can be paged back and forth as needed. Note that paging through the data may potentially start non-trivial computations in some cases (e.g., with a Spark DataFrame )","title":"Browse"},{"location":"docs/visualization-and-viz-cells/#plot","text":"The Plot view is the most complex part of a Viz Cell. It contains a Plot Editor which generates a Vega plot in a more straightforward manner, allowing customization of the plot type, selection of Dimensions and Measures to plot, and more without the need to edit Vega code directly. The example below shows the Plot Editor being used to generate the example graph shown in the Vega Cell documentation above . To extract the Vega spec generated by the editor, click on the to generate a Vega Cell that contains the generated spec.","title":"Plot"},{"location":"docs/visualization-and-viz-cells/#other-ways-to-visualize","text":"If the Reprs that Polynote automatically generates aren't enough, there are plenty of other ways to hook into Polynote's display capabilities.","title":"Other ways to visualize"},{"location":"docs/visualization-and-viz-cells/#defining-your-own-reprs","text":"If you'd like to add display capabilities to types in your code, you can implement your own Reprs by extending the ReprsOf trait. This allows you to register Reprs for your types. The easiest way to create a new Repr is to use a MIMERepr , which takes a MIME type and content string. For example, you to display some HTML you could return MIMERepr ( \"text/html\" , \"<h1>Heading</h1>\" ) , or to show an image you could return MIMERepr ( \"image/png\" , \"<a base64 encoding of a PNG>\" ) . Here's an example adding a simple HTML MIMERepr for the results of type MyThing . DOESN'T WORK! import polynote . runtime . _ case class MyThing ( a : String ) object MyThing { implicit object MyThingRepr extends ReprsOf [ MyThing3 ]{ override def apply ( value : MyThing ): Array [ ValueRepr ] = Array ( MIMERepr ( \"text/html\" , s\"<strong> ${ value . a } </strong>\" )) } } MyThing ( \"hi\" )","title":"Defining your own Reprs"},{"location":"docs/visualization-and-viz-cells/#using-kerneldisplay","text":"Let's say you just want to display some output, but you don't want to go through the trouble of defining a special Repr . You can use the kernel.display package (available in polynote.runtime ) to hook into Polynote's display mechanism. To display an HTML string, use kernel . display . html ( content : String ) , which takes in a String and outputs it as HTML. You can also display other MIME types using kernel . display . content ( mimeType : String , content : String ) , where content is a String representation of the content (e.g., base64 encoded for an image). In fact, kernel.display.html is actually a shortcut for kernel . display . content ( \"text/html\" , _ ) .","title":"Using kernel.display"},{"location":"docs/visualization-and-viz-cells/#visualization-with-python","text":"The Python ecosystem has a rich history of notebook usage with Jupyter/IPython, and many Python libraries define rich display representations for use in a notebook environment. Polynote supports these _repr_*_() methods, too! Polynote simply translates these methods into their corresponding MIMERepr . Polynote supports all of the _repr_*_() standard methods, including _repr_mimebundle_() . This means that the IPython.display API also works in Polynote. Additionally, Polynote understands pandas . DataFrame s and generates StreamingDataRepr s for them, just like it does for Spark. Finally, as shown in the tour , Polynote supports matplotlib , too!","title":"Visualization with Python"}]}